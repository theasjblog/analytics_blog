{
  "hash": "f9835d308dcfaa0e4d335e38ecdfc39f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Programmatic plumber - Part 1: the basics\"\ndescription: \"How to unlock the power of plumber API.\"\ndate: \"2023-11-22\"\ncategories: [ai]\n---\n\n\n\n![Image generated with Canva AI Magic Media.](img/cover.png)\n\n### What We'll Learn Today\n\nToday, we'll enhance our Plumber API skills by using “programmatic Plumber”. This will unlock features such as:\n\n* Simplifying complex APIs\n* Handling errors\n* Modifying routing\n\nIn this first part, we'll examine the basics of programmatic Plumber and how it can be used to reduce the complexity of large APIs.\n\n### Introduction\n\nIn a [previous article](../2023-08-01_intro_plumber/index.qmd), we discussed structuring an API in a clean, simple way using annotations to define the API. For instance, consider this API that returns a histogram plot:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plumber)  \n  \n#* @get myPlot  \n#* @serializer png  \nfunction() {  \n hist(rnorm(100))  \n}\n```\n:::\n\n\n\n\nThe lines of code starting with `#* @<tag_name>` are called annotations. We use them here to specify a `GET` endpoint and that the response must use the `png` serializer.\n\nUsing annotations to define an API is perfectly acceptable and, in fact, what I recommend for most beginners. Annotations allow you to visually separate the code required to define the API (server logic) from the code necessary to perform the API task (business logic).\n\nHowever, there are cases when we need more control over our endpoints and the routing of the request. In such scenarios, we should consider using programmatic Plumber development.\n\n### Our First Programmatic Plumber API\n\nLet's start by defining a router. In `{plumber}`, the router is responsible for handling the request, dispatching it to the endpoints, and managing any errors. We can initialize a router with:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(plumber)  \n  \npr_run(pr())\n```\n:::\n\n\n\n\nThis router is completely empty. Any incoming traffic will cause 404 errors as the router doesn't know how to handle requests.\n\nIf we want to stick to defining the API using annotations, we can pass a `plumber.R` file to the router to start a working API:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# entrypoint.R  \nlibrary(plumber)  \n  \npr_run(pr = plumb('plumber.R'))  \n\n\n# plumber.R  \n#* @get myPlot  \n#* @serializer png  \nfunction() {  \n hist(rnorm(100))  \n}\n```\n:::\n\n\n\n### The Basics\n\nThe first thing we want to do is convert our original annotation example into a programmatic version using the `pr_get`method:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# /R/myPlot.R  \nmyPlot <- function() {  \n\thist(rnorm(100))  \n}  \n  \n# plumber.R  \nlibrary(plumber)  \nlibrary(here)  \nsource(here::here('R', 'myPlot.R'))  \napi <- pr() %>%  \n pr_get(path = \"/myPlot\",  \n     handler = myPlot,  \n     serializer = serializer_png()) %>%  \n pr_run()\n```\n:::\n\n\n\n\nIt's fairly straightforward to convert the annotations into programmatic definitions. The annotations become arguments to the `pr_get` method.\n\n**Note:** RStudio uses the annotations to automatically recognize a `{plumber.R}` file as an API file. When you use annotations, RStudio will display a “Run API” button. When you use programmatic `{plumber}`, RStudio will not show that option. You can still run the API using `source`.\n\nSo far, we know how to convert existing annotated APIs into programmatic APIs, but it's not yet clear why we should do it. We have not unlocked any new functionalities, nor have we simplified our code.\n\nIn the next section, we will see how using programmatic `{plumber}` can simplify our codebase.\n\n### Merge multiple endpoints\n\nThe `pr_mount` method allows us to nest endpoints within each other. This technique is crucial for managing the complexity of large APIs. When we use `pr_mount`, we can define logically separated groups of endpoints in separate files, and then merge them together in a single root API.\n\nConsider an example where everything is defined in the same file. We will have two endpoints: `plots`, which we already know, and `randLetters`, which will return some randomly generated letters.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n######## R/myPlot.R  \nmyPlot <- function() {  \n\thist(rnorm(100))  \n}  \n  \n# R/randLetters.R  \nrandomLetters <- function(n = 10) {  \n print('letters calculation')  \n sample(letters, n, replace = TRUE)  \n}  \n\n\n######### plumber.R  \nlibrary(plumber)  \nlibrary(here)  \n\n# define root router  \nroot <- pr()  \n# define the plot router  \nplots <- pr() %>%  \n pr_get(path = '/myPlot',  \n     handler = myPlot,  \n     serializer = serializer_png())  \n\n# define the random letters generator router  \nrandLetters <- pr() %>%  \n pr_get(path = '/randLetters',  \n     handler = randomLetters,  \n     serializer  = serializer_json())  \n\n# mount to root  \nroot %>%  \n pr_mount('/mountPath_1', plots) %>%  \n pr_mount(\"/mountPath_2\", randLetters) %>%  \n pr_run()\n```\n:::\n\n\n\n\nIf we start the API, we will see two endpoints: `/mountPath_1/plots` and `/mountPath_2/randLetters`.\n\nDefining all routers in the `plumber.R` file is not ideal. We can compartmentalize the code as follows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n############## inst/plumber_myPlot.R  \nlibrary(plumber)  \nlibrary(here)  \nlapply(list.files(here::here('R'), full.names = TRUE),  \n         function(d) {source(d)})  \n  \nplots <- pr() %>%  \n pr_get(path = \"/myPlot\",  \n     handler = myPlot,  \n     serializer = serializer_png())  \n\n\n############## inst/plumber_myPlot.R  \nlibrary(plumber)  \nlibrary(here)  \nlapply(list.files(here::here('R'),  \n         full.names = TRUE),  \n    function(d) {source(d)})  \nrandLetters <- pr() %>%  \n pr_get(path = '/randLetters',  \n     handler = randomLetters,  \n         serializer = serializer_json())  \n\n\n################# plumber.R  \nlibrary(plumber)  \nlibrary(here)  \n\n# source the individual routers  \nsource(here::here('inst', 'plumber\\_myPlot.R'))  \nsource(here::here('inst', 'plumber\\_randLetters.R'))  \n\n# root router  \nroot <- pr()  \n\n# mount to root  \nroot %>%  \n pr_mount('/mountPath_1', plots) %>%  \n pr_mount(\"/mountPath_2\", randLetters) %>%  \n pr_run()\n```\n:::\n\n\n\n\nThe advantage of using `pr_mount` is that we can break down the complexity of large APIs. Additionally, we can execute and test each routing independently, without having to load the entire root API.\n\n### Conclusion\n\nThis concludes the first part of this series on programmatic `{plumber}`.\n\nWe've seen how we can easily convert from annotation to programmatic style and how we can keep existing annotated `plumber.R` APIs and enrich them with programmatic APIs.\n\nWe also discussed how we can use programmatic `{plumber}` to manage the complexity of large APIs using mounting.\n\nIn the next article, we will explore more powerful features of programmatic `{plumber}`: error handling and defining the API documentation.\n\n### Resources\n\n* [Official plumber documentation](https://www.rplumber.io/articles/programmatic-usage.html)",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}