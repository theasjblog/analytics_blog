{
  "hash": "0eaac4353c9998ec5d82d61338f7d5ca",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"S3, S4, RC, R6. Object oriented in R - Part 2\"\ndescription: \"RC and R6 objects.\"\ndate: \"2022-09-20\"\ncategories: [r, oop]\n---\n\n\n![](img/cover.png)\n\nThis article builds on the concepts that I introduced in [part 1](/posts/2022-09-12_oop_r_1/index.html).\n\n**Topics in part 2**\n\n* RC objects.\n* R6 objects.\n* Final considerations\n\n# RC objects\n\nReference class (RC) is part of base R and it is a very different implementation of OO in R compared to S3 or S4. While S3 and S4 represent functional OO, RC is encapsulated OO. In RC, methods belong to a class, and not to a function.\n\nRC will look familiar to traditional OO developers. Traditional OO is formally defined and it is encapsulated. However, RC syntax and behaviour is not friendly to pure R developers. We will see some examples of this later.\n\nLet’s look at an RC implementation of the Animals example.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nAnimals <- setRefClass(\n  \"Animals\",  \n  # Fields of the class   \n  fields = list(species = \"character\"),   \n  # Methods of the class   \n  methods = list(     \n    # Initialize the class    \n    initialize = function(species = \"\") {      \n      if (species != \"\") {\n        # Validate the inputs      \n        validate(species)      \n        .self$species <- formatSpecies(species)\n      }\n    }, \n    # User-friendly console class print \n    show = function() {    \n      cat(\"Object of class 'Animals'. The species is \", .self$species, \"\\n\")     \n    },    \n    # Validate the class inputs \n    validate = function(input_species) { \n      if (!is.character(input_species)) {  \n        stop(\"species must be a character\")       \n      }   \n      if (is.na(input_species)) {  \n        stop(\"species cannot be NA\")       \n      }     \n      if (!stringr::str_detect(input_species, '[a-zA-Z]+ [a-zA-Z]+')) {    \n        stop(\"species must contain genus and species separated by a single space.\")       \n      }     \n    },   \n    # Format the species   \n    formatSpecies = function(str) {   \n      return(stringr::str_to_sentence(str))     \n    }   \n  )\n)\n\nnewAnimal <- Animals(species = 'Canis Familiaris')\nnewAnimal$show() # equivalent to show(newAnimal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class 'Animals'. The species is  Canis familiaris \n```\n\n\n:::\n:::\n\n\n\nWe created the class Animals with the following attributes:\n\n* **fields**: this is the list of variables inside the objects.\n* **methods**: the methods belonging to the class.\n\nThe `initialize` method first validates the inputs, then it formats the species string, and finally it initializes the object.\n\nIn real-life application, we can consider the example above a low-level constructor. You might want to provide the user with a user friendly constructor to create an object. Expensive validation checks can be reserved to the user-exposed constructor.\n\nIf the class definition becomes too long it may be advisable to break it down in small chunks. We can attach methods to a class definition by using the `<class_name>$methods(<method_name> = function(){})` syntax.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# define the class\nmyClass <- setRefClass(\"myClass\",\n                       fields=c(field1='character',\n                                field2='numeric'))\n# add a method\nmyClass$methods(\n  show = function(){\n    ...\n  }\n)\n\n# add another method\nmyClass$methods(\n  awsomeCalculation = function(){\n    ...\n  }\n)\n```\n:::\n\n\n\n## Inheritance\n\nRC supports inheritance through the contains argument of the constructor. Let’s consider our Dog subclass.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDog <- setRefClass(\n  \"Dog\",\n  contains = 'Animals',\n  fields=c(name=\"character\",\n           age = 'numeric'),\n  methods=list(\n    initialize = function(name, age){\n      validate(name, age)\n      .self$name <- name\n      .self$age <- age\n      .self$species <- 'Canis familiaris'\n    },\n    show = function(.self){\n      cat(\"The dog \", .self$name,\n          \" is \", .self$age)\n    },\n    validate = function(name, age){\n      if (!is.character(name)){\n        stop(\"name must be a character\")\n      }\n      if (is.na(name)){\n        stop(\"name cannot be NA\")\n      }\n      if (!is.numeric(age)){\n        stop(\"age must be a numeric\")\n      }\n      if (is.na(age)){\n        stop(\"age cannot be NA\")\n      }\n      if (age<0){\n        stop(\"age cannot be <0\")\n      }\n    },\n    updateAge = function(age){\n      oldAge <- .self$age\n      .self$age <- age\n      return(oldAge)\n    },\n    humanAge = function(){\n      return(.self$age*7)\n    }\n  )\n)\n\nnewDog <- Dog(name='Pluto', age = 4)\nnewDog$show()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe dog  Pluto  is  4\n```\n\n\n:::\n\n```{.r .cell-code}\nnewDog$field('species')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Canis familiaris\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnewDog$updateAge(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nnewDog$show()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe dog  Pluto  is  5\n```\n\n\n:::\n\n```{.r .cell-code}\nnewDog$humanAge()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 35\n```\n\n\n:::\n:::\n\n\n\nThe way we define the class and its methods is identical to the way we defined Animals. However, since we used contains, Dog is a subclass of Animals. We can see this from the field species. We did not define species in fields, but we inherited it from Animals.\n\nIf we need to call a method from the superclass and resolve name conflicts, we can use the callSuper method.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#define the class\nDogShow <- setRefClass(\n  \"DogShow\",\n  contains = 'Animals',\n  fields=c(name=\"character\",\n           age = 'numeric'),\n  methods=list(\n    initialize = function(name, age){\n      .self$name <- name\n      .self$age <- age\n      .self$species <- 'Canis familiaris'\n    },\n    show = function(){\n      superClass()\n    }\n  )\n)\n\nnewDog <- Dog(name='Pluto', age = 4)\nnewDog$show()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe dog  Pluto  is  4\n```\n\n\n:::\n:::\n\n\nNote how the show method is inherited from Animals, and we call it from Dog using the superClass function.\n\n## RC is mutable\n\nRC objects are mutable. That is, we can modify the object and return a value at the same time. In the Dog example we demonstrated this in the method `updateAge`. This method modifies the object to update the age field. At the same time, it returns the previous age. This is a powerful feature, but we need to be careful. Mutability is not a natural behaviour in R: it can catch developers by surprise. It also makes it more difficult to reason about the effects and behaviours of objects. Limit mutability as much as possible and always separate side effects (modifying an object) from direct returns.\n\n## Built-in methods\n\nRC has several built-in methods. We already saw some of them, like field to access a field, or methods to create new methods for an object.\n\n`copy` is an important built-in method. It highlights a fundamental difference between “standard” R behaviour and RC behaviour. As the name reference implies, when we create a copy of a `ReferenceClass` object we do not create an independent copy, but a referenced one. This means that if we modify one version of the object, we also modify its copy. To make an independent copy, we need to use the copy method.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnewAnimal <- Animals$new(species = 'Canis Familiaris')\nnewAnimal$show()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class 'Animals'. The species is  Canis familiaris \n```\n\n\n:::\n\n```{.r .cell-code}\n# make a copy, the R way\ncopyNewAnimal <- newAnimal\ncopyNewAnimal$show()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class 'Animals'. The species is  Canis familiaris \n```\n\n\n:::\n\n```{.r .cell-code}\n# modify the original\nnewAnimal$field('species', 'hello world')\nnewAnimal$show()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class 'Animals'. The species is  hello world \n```\n\n\n:::\n\n```{.r .cell-code}\ncopyNewAnimal$show() # note that this has been modified\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class 'Animals'. The species is  hello world \n```\n\n\n:::\n\n```{.r .cell-code}\n# make a deep copy\nnewAnimal <- Animals$new(species = 'Canis Familiaris')\ncopyNewAnimal <- newAnimal$copy()\n# modify the original\nnewAnimal$field('species', 'hello world')\nnewAnimal$show()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class 'Animals'. The species is  hello world \n```\n\n\n:::\n\n```{.r .cell-code}\ncopyNewAnimal$show() # note that this has NOT been modified\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class 'Animals'. The species is  Canis familiaris \n```\n\n\n:::\n:::\n\n\n\nTo an R developer this looks very strange and unexpected. You can anticipate it will create several problems if not used carefully.\n\nOther built-in methods are:\n\n* **new**: used to initialize the object. `newAnimal <- Animals$new()` is equal to `newAnimal <- Animals()`.\n* **help**: provides help documentation.\n* **methods**: creates new methods.\n\nA complete list can be found on the [RC documentation page](https://www.rdocumentation.org/packages/methods/versions/3.6.2/topics/ReferenceClasses).\n\n## Wrap up\n\nRC objects are appealing to developers familiar with OO in other languages. RC provides support to familiar patterns and concepts, for instance encapsulation. However, it uses mechanisms like mutability that are not familiar to the R language. These mechanisms can make the code harder to read and maintain for R developers.\n\nFurthermore, RC is poorly documented: all of its documentation is in [this page](https://www.rdocumentation.org/packages/methods/versions/3.6.2/topics/ReferenceClasses). RC is also slower than R6, which is based on the same principles.\n\nFinally a note on private methods. In RC there is no (easy) way to create private methods or fields. If you search stackoverflow hard enough you will find some workarounds, but they are just that: workarounds.\n\nFor all these reasons, it is difficult to recommend RC in any instance. If you need the added complexity of RC mutability and encapsulation, use R6 instead. The only case when you want to consider RC is when you work on legacy code and RC is already used.\n\n# R6\n\nR6 is another implementation of encapsulated OO. It is not part of base R and you will need to install the R6 package. R6 shares many functionalities with RC, but it is based on S3, rather than S4.\n\nLet’s have a look at how we can write the Animals class.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(R6)\n# define class\nAnimals <- R6Class(\n  'Animals',\n  # public methods\n  public = list(\n    species = NULL,\n    initialize = function(species){\n      private$validate(species)\n      self$species <- private$formatSpecies(species)\n    },\n    print = function(){\n      cat(\"Object of class 'Animals'. The species is \",\n          self$species)\n    }\n  ),\n  # private methods\n  private = list(\n    validate = function(species){\n      if (!is.character(species)){\n        stop(\"species must be a character\")\n      }\n      if (is.na(species)){\n        stop(\"species cannot be NA\")\n      }\n      if (!stringr::str_detect(species, '[a-z, A-Z] [a-z,A-Z]')){\n        stop(\"species must contain genus and species separated by a single space.\")\n      }\n    },\n    formatSpecies = function(species){\n      return(stringr::str_to_sentence(species))\n    }\n  )\n)\n\n# create the class\nnewAnimal <- Animals$new(species='Canis Familiaris')\n# print\nnewAnimal$print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class 'Animals'. The species is  Canis familiaris\n```\n\n\n:::\n:::\n\n\n\nR6 supports private methods and fields through the argument private. You can access private methods and fields from the public methods using the private$ notation, as illustrated in the initialize method above.\n\n## Piping\n\nR6 supports \"piping\". Similarly to how you would pipe `dplyr` or `recipe` verbs, you can pipe R6 methods using the `$` operator.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# piping\nnewAnimal <- Animals$new(species='Canis Familiaris')$print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class 'Animals'. The species is  Canis familiaris\n```\n\n\n:::\n:::\n\n\n\n## Inheritance\n\nR6 inheritance requires the use of the inherit argument in the class definition.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDog <- R6Class(\n  'Dog',\n  inherit = Animals,\n  public = list(\n    name = NULL,\n    age = NULL,\n    initialize = function(name, age){\n      private$validate(name, age)\n      self$species <- 'Canis familiaris'\n      self$age <- age\n      self$name <- name\n    },\n    print = function(){\n      cat(\"The dog \", self$name,\n          \" is \", self$age)\n    },\n    updateAge = function(age){\n      oldAge <- self$age\n      self$age <- age\n      return(oldAge)\n    },\n    humanAge = function(){\n      return(self$age * private$dog_human_age_ratio)\n    }\n  ),\n  private = list(\n    dog_human_age_ratio = 7,\n    validate = function(name, age){\n      if (!is.character(name)){\n        stop(\"name must be a character\")\n      }\n      if (is.na(name)){\n        stop(\"name cannot be NA\")\n      }\n      if (!is.numeric(age)){\n        stop(\"age must be a numeric\")\n      }\n      if (is.na(age)){\n        stop(\"age cannot be NA\")\n      }\n      if (age<0){\n        stop(\"age cannot be <0\")\n      }\n    },\n    formatSpecies = function(species){\n      return(stringr::str_to_sentence(species))\n    }\n  )\n)\n\n# usage\n# create new object\nnewDog <- Dog$new(name='Pluto', age=4)\nnewDog$print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe dog  Pluto  is  4\n```\n\n\n:::\n\n```{.r .cell-code}\nnewDog$humanAge()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 28\n```\n\n\n:::\n\n```{.r .cell-code}\nnewDog$updateAge(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\nnewDog$print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe dog  Pluto  is  5\n```\n\n\n:::\n:::\n\n\n\nWe can access both public and private attributes of the superclass using super, as demonstrated in the example below.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDogShow <- R6Class(\n  \"DogShow\",\n  inherit = Animals,\n  public = list(\n    name=NULL,\n    age=NULL,\n    initialize = function(name, age){\n      self$name <- name\n      self$age <- age\n      self$species <- 'Canis familaris'\n    },\n    # call the superclass method\n    print = function(){\n      super$print()\n    }\n  )\n)\n                   \nnewDog <- DogShow$new(name='Pluto', age=4)\nnewDog$print()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class 'Animals'. The species is  Canis familaris\n```\n\n\n:::\n:::\n\n\n\n## R6 is mutable\n\nR6 objects are mutable, and as for RC we demonstrated this with the updateAge method.\n\nRemember that mutability is not a normal R behaviour. If you can master it, it is not guaranteed that your team members can as well, so plan to document it very well. Your goal is to create code that is easier to work with, not to show off with something no one else can understand.\n\n## Built-in methods\n\nR6 objects have built-in methods. The most notable one is `clone`. `clone` allows you to create deep copies of the object.\n\n## Wrap up\n\nRC and R6 are both familiar to traditional OO developers. RC and R6 syntaxes and feature-sets are similar. One of the key differences is that R6 has native support for private methods.\n\nThere are two key differences between RC and R6: performance and documentation. R6 performs better than RC, this is one of the reasons why Shiny switched from RC to R6. As for documentation, R6 is better documented than RC.\n\n# Object oriented in R: final wrap up\n\nR is a functional language. Yet, R supports object oriented programming. The native R object oriented is of the functional type. In this implementation, methods belong to a function (the generic), rather than to a class. Different classes can plug in new methods to existing generics. This type of classes are not defined formally, and may look very strange to non-R developers.\n\nR has two types of functional OO: S3 and S4. S3 are well documented and are embedded in base R. Functions like print or summary are in fact S3 generics. We can create new S3 classes and take advantage of these existing generics. All we have to do is to write new methods. This will be very natural to R developers. Also, the resulting syntax will use common R verbs.\n\nS4 is more complex than S3. They are formally defined and this added rigidity can ease work in larger teams. This is one of the main reasons why S4 is the backbone of the BioConductor project.\n\nIf you need “traditional” encapsulated object oriented, then you can use RC or R6. R6 even supports private attributes. The downside of RC and R6 is that they have properties that are not standard to R, such as mutability and shallow copies. These features can cause confusion to other team members that are not familiar with them. Remember that you work in a team and you must aim to deliver the best possible solution. This is the solution that everybody can understand and maintain, and not the most technically advanced one.\n\nWhen I work with objects, I tend to work with a combination of S3, S4, and only in minor part R6. I use S4 or R6 for classes exposed to the user and S3 for internal methods. In this way I can leverage a formal definition of the interface on the outside layer of the application. At the same time, I can use the flexibility of S3 when I don’t have to worry about external inputs. I use R6 only when I have to work with non-R developers who are familiar with OO. They tend to find R6 comfortable to work on, while they start to grasp S3 and S4 concepts as well.\n\nBelow is a quick reference table to help you define your R’s OO strategy.\n\n![Comparing different R OOP frameworks.](img/comparison.png)\n\n| Type of object oriented         | S3        | S4               | RC                   | R6                            |\n|----------------------------------|-----------|------------------|----------------------|-------------------------------|\n| Familiar to the average R developer | Yes       | In part          | No                   | No                            |\n| Formally defined                | No        | Yes              | Yes                  | Yes                           |\n| Mutable                         | No        | No               | Yes                  | Yes                           |\n| Shallow/Deep copy (reference semantics) | Only deep | Only deep        | Yes                  | Yes                           |\n| Documentation                   | Great     | Good             | Poor                 | Good                          |\n| Speed                           | Fast      | Fast             | Slower               | Fast                          |\n| Included in base R              | Yes       | Yes              | Yes                  | No                            |\n| Supports inheritance            | Yes, but needs to be planned even in the superclass | Yes | Yes | Yes |\n| Generally recommended           | Yes, it is the native OO in R, and it forces you to simplify your code | Yes, in larger teams | Only if it is already used | Only for very experienced R teams |\n\nI hope you found this quick guide to object oriented in R useful. Subscribe and follow if you want to get more tips on how to improve your coding.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}