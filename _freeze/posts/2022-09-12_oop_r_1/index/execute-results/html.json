{
  "hash": "5cfdbe6b173318a5d0d4030affe485a9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"S3, S4, RC, R6. Object oriented in R - Part 1\"\ndescription: \"Introduction to object oriented in R, S3 and S4 objects.\"\ndate: \"2022-09-12\"\ncategories: [r, oop]\n---\n\n\n![](img/cover.png)\n\n\n**Topics in part 1**\n\n*. What is object oriented (OO)?\n* How does R implement OO?\n* Case study.\n* S3 objects.\n* S4 objects\n\n# What is object oriented programming?\n\nObject oriented (OO) is one of the three main paradigms in programming. It has revolutionized programming, along with structured programming and functional programming. OO is very popular, particularly with languages such as Python, Java, C#, and many more. But what is object oriented programming? OO is often defined by features like encapsulation, polymorphism, and inheritance. I prefer to use the definition from R.C. Martin:\n\nOO languages have absolute control over the direction of all source code.\nIn other words, OO can control dependencies in a very exact manner.\n\nHow can we harness that power in R?\n\n# OOP in R\n\nR is a functional language by design. You decompose a problem and solve it with functions, rather than with objects. Yet, R supports OO. In fact, in R you use objects and methods all the time, even if you do not realize it. Entities such as data.frame, list, and vectors are classes. And they all have their methods such as print or summary. Those methods behave differently depending on the class you use them on.\n\nR supports two types of OO programming: functional OOP and encapsulated OOP.\n\n## Functional OO programming\n\nIn functional OO programming, methods belong to generic functions. Functional OO programming resembles standard functional programming, at least from the outside. Functional objects in R are S3 and S4 objects.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note: this example is a mock up: it will not work if you try to run it. It only \n# serves as a guide to showcase the components of functional OOP\n\n# create an object of class \"myObject\"\nmyObject <- object(list(a=5,\n                        b=\"hello\"),\n                   class=\"myObject\")\n                   \n# define a generic to print it. This generic takes\n# our object and dispathc the print call to the appropriate method\n# based on the class of myObject\nprint <- funciton(obj){\n  useMethod(obj)\n}\n# now we define the exact method to print our object. The method is not\n# encapsulated into the function definition, it belongs to the generic \n# function print(). This is funcitonal OOP\nprint.myObject <- function(obj){\n  cat(rep(obj$b, obj$a))\n}\n\n# use the print method\nprint(myObject)\n```\n:::\n\n\n\n\n## Encapsulated OO programming\n\nIn encapsulated OO programming, methods belong to classes: they are encapsulated. If you are familiar with Python or Java OO programming, this is the same principle. Encapsulated objects in R are R6 and RC objects.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note: this example is a mock up: it will not work if you try to run it. It only \n# serves as a guide to showcase the components of encapsulated OOP\n\n# create an object. Note how the print method is defined inside the class: it is encapsulated\n# in the class\nmyObject <- newObject(fields=list(a=5,\n                                  b=\"hello\"),\n                      methods=list(print = function(self){\n                      cat(rep(self$a, self$b))}))\n\n# use the print method\nmyObject$print()\n```\n:::\n\n\n\nIn this mini-series we will first look at R’s implementation of OO, and at the pros and cons of different solutions.\n\n# The example\n\nIn this series we will use a common example for all the objects we will explore. We will define a class Animals with some attributes and methods. We will then define a subclass of Animals: Dog. We will use Dog to show inheritance.\n\nSome attributes and operations should be public (+), while others should be private (-).\n\n![The classes used in this series.](img/class.png)\n\nAs always, I want to give you the knowledge you need to design solutions based on good decisions. I do not aim to give you every possible single detail of the OO implementation. If you want to know all the details, Hadley Wickham has an excellent book: [Advanced R](https://adv-r.hadley.nz/index.html).\n\n# S3\n\nS3 is the simplest and most common form of OO programming in R. Its implementation is quite relaxed, especially when compared to traditional OO languages. Yet, it is very versatile, and there is merit to its simplified approach.\n\nTo understand what I mean, let’s start to work on our example class: Animals.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the class \"Animals\"\nanimals <- list(species = \"Canis familiaris\")\nclass(animals) <- \"Animals\"\n\n# default print\nanimals\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$species\n[1] \"Canis familiaris\"\n\nattr(,\"class\")\n[1] \"Animals\"\n```\n\n\n:::\n:::\n\n\n\nThis is very informal. We created a list and changed its class attribute from list to Animals.\n\nIn general, whenever we create an S3 object we want to create three functions:\n\n* An **internal constructor**. This creates the list and changes the class to Animals. This is not exposed to the user. It is a developer function. The constructor name should start with new_.\n* A **validator** to validate the inputs a user provides to create a class.\n* A user-friendly **class builder** exported to the user. A user will call this to build an object. The builder will call the validator and the internal constructor.\n\nThis is how we can write the three functions for our class.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# define the internal constructor\nnew_Animals <- function(obj){\n  # obj must be a string\n  animals <- list(species = obj)\n  class(animals) <- \"Animals\"\n  \n  return(animals)\n}\n\n# define a validator\nvalidate_Animals <- function(animals){\n  # obj is the character string that the user will pass to create an object.\n  # It must of length 1 and not NA. Note that we already validate that the \n  if(class(animals) != \"Animals\"){\n    stop(\"The object is not of class 'Animals'\")\n  }\n  if (is.null(attr(animals, \"names\"))){\n    stop('Missing class attribute \"names\"')\n  }\n  if (attr(animals, \"names\") != \"species\"){\n    stop('Missing class attribute \"species\"')\n  }\n  if (!is.character(animals$species)){\n    stop(\"species must be a character\")\n  }\n  if (is.na(animals$species)){\n    stop(\"species cannot be NA\")\n  }\n  if (!stringr::str_detect(animals$species, '[a-z, A-Z] [a-z,A-Z]')){\n    stop(\"species must contain genus and species separated by a single space.\")\n  }\n  return(TRUE)\n}\n\n# user exposed constructor. In roxygen, we use the @export tag\n# for this function\nAnimals <- function(species = \"Undefined Animal\"){\n  animals <- new_Animals(species)\n  validate_Animals(animals)\n  return(animals)\n}\n\n# use the constructor\n# passing a wrong input\ntryCatch({\n  res <- Animals('hello')\n},\nerror = function(msg){msg})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<simpleError in validate_Animals(animals): species must contain genus and species separated by a single space.>\n```\n\n\n:::\n\n```{.r .cell-code}\n# passing a correct input\nres <- Animals('Canis Familiaris')\nprint(res)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$species\n[1] \"Canis Familiaris\"\n\nattr(,\"class\")\n[1] \"Animals\"\n```\n\n\n:::\n:::\n\n\n\nLet’s unpack.\n\n`new_Animals` is the internal constructor. This is not exposed to the user, but it is a quick way to build an object internally, i.e. from within a package.\n\n`validate_Animals` is the object validator. It checks that we have an object of the right class and with the right attributes. Note that you could include these simple checks in the internal constructor. As a rule of thumb, include expensive checks in the validator and cheap checks in the internal constructor. In this way you can run expensive checks only when needed. However, I prefer a stricter segregation of responsibilities. I put all my checks in the validator, not in the constructor.\n\n`Animals` is the builder exposed to the user. This function builds the object and then it validates it.\n\n## Generics and methods\n\nWe now need to create our two methods: `print` and `formatSpecies`. `print` will print a user friendly summary of our object, rather than the one we get by default. `formatSpecies` will format the species string.\n\nIn S3 we cannot create private methods. All our methods will be public.\n\nLet’s start from the `print` method. A generic `print` already exists in R. You can call it on any variable to see its value printed to the console. In fact, print is an S3 generic. We can use it and create a new method for the class `Animals`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# s3 print method for the class Animals\nprint.Animals <- function(obj){\n  cat(paste0(\"Object of class 'Animals'. The species is \",\n             obj$species))\n}\n\n# create a new object\nnewAnimal <- Animals('Canis Familiaris')\n\nprint(newAnimal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class 'Animals'. The species is Canis Familiaris\n```\n\n\n:::\n:::\n\n\n\nNote how the output of `print` is now different from the code snippet we used above, where the method was not defined yet.\n\nA very important thing to keep in mind is the naming convention for S3 methods. S3 methds must be defined using `<generic>.<class>`. This is the internal R convention needed to get the dispatch mechanism to work. In our example, we called the method `print.Animals`\n\nLet’s now create `formatSpecies`. This method does not have a generic, so we need to create it.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# the generic\nformatSpecies <- function(x) {\n  UseMethod(\"formatSpecies\")\n}\n\n# the method for the class Animals\nformatSpecies.Animals <- function(obj){\n  obj$species <- stringr::str_to_sentence(obj$species)\n  return(obj)\n}\n\n# create a new object. Note the lower case in the species\nnewAnimal <- Animals('canis familiaris')\n# call the generic\nformattedAnimals <- formatSpecies(newAnimal)\n# verify the results. Note the capitalization\nprint(formattedAnimals)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class 'Animals'. The species is Canis familiaris\n```\n\n\n:::\n:::\n\n\n\nThe generic `formatSpecies` will match the appropriate method to the object. It will then dispatch the call to that method: `formatSpecies.Animals`.\n\n## Inheritance\n\nInheritance in S3 revolves around the concept that a class can be a vector of length greater than 1. That is, an object can have two or more classes. you can find an example of this behaviour in the {`tibble`} package.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a tibble\nmtCarsTibble <- tibble::as_tibble(mtcars)\n\nclass(mtCarsTibble)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\nA tibble object has three classes: `tbl_df`, `tbl`, and `data.frame`. This reflects the order of inheritance: `tbl_df` is a subclass of `tbl`, which in turn is a subclass of `data.frame`.\n\nWhen we use a generic on an object like this R will try to dispatch to a method in the specified order. If a method for `tbl_df` is not found, then R will look for a method for the class `tbl`, and finally for the class `data.frame`.\n\nLet’s see how we can use this in our example. Before we create the subclass, we need to change the superclass. This is because in S3 inheritance is not automatic: we need to add it into the superclass.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Animals class accepting subclasses\nnew_Animals <- function(obj, ..., class = character()){\n  animals <- list(species = obj)\n  class(animals) <- c(class, \"Animals\")\n  \n  return(animals)\n}\n```\n:::\n\n\n\nWe made three changes:\n\n* We added the argument `...`. This allows us to pass to the superclass any extra argument required by the constructor.\n* We added the argument `class=character()`. This allows us to specify the subclass and to create the class vector as we saw in the tibble example.\n* We defined the class as `c(class, \"Animals\")`, rather than just `Animals`. Once again, this allows us to create the class vector of length greater than 1.\n\nNow that the superclass can accept subclasses, let’s create the Dog subclass.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create the Dog subclass constructor\nnew_dog <- function(x, age) {\n  newObj <- new_Animals(\"Canis familiaris\", class = \"Dog\")\n  newObj$name <- x\n  newObj$age <- age\n  return(newObj)\n}\n\n# create an object\nmyDog <- new_dog('Pluto', 2)\n\n# check the class\nclass(myDog)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Dog\"     \"Animals\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# print the object\nprint(myDog)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class 'Animals'. The species is Canis familiaris\n```\n\n\n:::\n:::\n\n\n\nIn line 3, we call the `Animals` superclass constructor, but we specify that we want to use class `Dog`. In line 14 we see how the class of `myDog` is a vector with two elements: `Dog` (the subclass), and `Animals` (the superclass). If we try to use the print method, R will use the print method defined for the class Animals. This is because we have not defined a print method for `Dog`. Let’s do that.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# print method for class Dog\nprint.Dog <- function(x) {\n  cat(paste0(\"The dog \", x$name,\n             \" is \", x$age))\n}\n\nprint(myDog)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe dog Pluto is 2\n```\n\n\n:::\n:::\n\n\n\nNow that we have a print method for Dog, R will use that and not the method for `Animals` anymore. We do not need to define the generic print as that is already defined in base R. We only create the method for the subclass.\n\nFinally, we can use the same syntax to create the new method `humanAge`. This method will calculate the age of the dog in “human” years.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# the generic humanAge. We could use it to plug in\n# more animals, rather than just dogs\nhumanAge <- function(x) {\n  UseMethod(\"humanAge\")\n}\n\n# the method for the class Dog\nhumanAge.Dog <- function(obj){\n  return(obj$age * 7)\n}\n\nhumanAge(myDog)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 14\n```\n\n\n:::\n:::\n\n\n\nThere is nothing we have not seen already here: we defined the generic (`humanAge`), and then the method associated with both the generic and the class (`Dog`).\n\n## S3 are not mutable\n\nConsider this scenario. It’s your dog’s birthday. You want a new method that can update your dog’s age. It should return the previous age and update the internal age. S3 objects cannot do this. S3 objects are not mutable. They cannot modify the input argument because they are based on functions.\n\nIf we want to update an object and return a result from the same call we must use a workaround. We need to create a function that:\n\n1. Modifies the input object to update the age.\n2. Returns the modified object in a list.\n3. Append to the list the previous age.\n4. In the main environment, unpack the list with assignments statements.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# define the generic\nupdateAge <- function(x) {\n  UseMethod(\"updateAge\")\n}\n\n# define the method\nupdateAge.Dog <- function(obj){\n  oldAge <- obj$age\n  obj$age <- obj$age + 1\n  # we need to wrap the updated object and the desired outcome\n  # into a list\n  return(list(obj = obj, oldAge = oldAge))\n}\n\n# call the generic\nres <- updateAge(myDog)\n# assignments\noldAge <- res$oldAge\nmyDog <- res$obj\n\nprint(oldAge)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(myDog)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe dog Pluto is 3\n```\n\n\n:::\n:::\n\n\n\nThe method `updateAge.Dog` returns a list containing both the previous age and the modified object.\n\nThis is awkward and a lot less elegant than traditional encapsulated OO, where objects are mutable. We will see the difference when we explore the R6 objects.\n\n## S3 wrap up\n\nS3 are simple objects. They are informal and relaxed in their definition. You can even change their structure after they are created. There is no formal validator. S3 does not have the concept of “private”, everything is “public”. Also, S3 are not mutable. Their function-oriented behaviour can be off-putting to the non-R crowd. In essence, S3 objects are just a bit more than glorified lists.\n\nBut don’t dismiss them too quickly. There is beauty and purpose in S3's simplicity. For example, it is very easy to plug in new methods for new classes to existing generics.\n\nS3 is not the best option if you need encapsulated mutable methods or a solid inheritance mechanism. Also, large teams developing on the same code base might struggle as a consequence of the lack of structure at the interface.\n\nYet, in most cases S3 should be the first option to consider. After all, there must be a reason if they are the most common type or R objects. There is a lot to gain by simplifying your code so that it works with S3.\n\n# S4\n\nS4 is a stricter implementation of S3. S4 is still functional OO, but classes are formally defined. You can no longer change the structure of an object after it has been created. S4 supports more sophisticated inheritance and dispatch mechanisms.\n\nLet’s see how we can create our `Animals` class in S4.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# define the class\nsetClass(\"Animals_s4\", \n         slots = c(species = \"character\")\n)\n\n# create an  object\nnewAnimal <- new(\"Animals_s4\", species=\"Canis familaris\")\n\n# default print\nshow(newAnimal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAn object of class \"Animals_s4\"\nSlot \"species\":\n[1] \"Canis familaris\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# access slots, method 1 \nnewAnimal@species\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Canis familaris\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# access slots, method 2 (recommended)\nslot(newAnimal, 'species')\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Canis familaris\"\n```\n\n\n:::\n:::\n\n\n\nWe can see a few differences from S3. We need to define the class content (`slots`) using representation . If we try to add another slot to the object after it is created or to assign something other than a character to species, we will get an error. We also notice that to access a slot we use `@` rather than `$` , or we can use the S4 function `slot()`.\n\nWe now have the basic object, let’s add a validator.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\n# # without validations, this will work\n# newAnimal <- new(\"Animals\", species=NA_character_)\n\n\n# define a validator\nvalidate_Animals <- function(object){\n  # species cannot be NA\n  if (is.na(slot(object, 'species'))){\n    stop(\"species cannot be NA\")\n  }\n  # there must be a white space between species and genus\n  if (!stringr::str_detect(slot(object, 'species'), '[a-z, A-Z] [a-z,A-Z]')){\n    stop(\"species must contain genus and species separated by a single space.\")\n  }\n  return(TRUE)\n}\n\n# add the validator to the class\nsetValidity('Animals_s4', validate_Animals)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClass \"Animals_s4\" [in \".GlobalEnv\"]\n\nSlots:\n                \nName:    species\nClass: character\n```\n\n\n:::\n\n```{.r .cell-code}\n# now this will fail\ntryCatch({\n  newAnimal <- new(\"Animals_s4\", species = NA_character_)\n},\nerror = function(msg){msg})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n<simpleError in validityMethod(object): species cannot be NA>\n```\n\n\n:::\n:::\n\n\n\nOur validator `validate_Animals` is based on the one we used for S3, but it is more lightweight. We are not testing for species to be a character or not to be `NULL`. This is because those checks come for free after we define species as a character in the constructor. We only need to check for species to be in the format we want.\n\nAfter we define the validator function validate_Animals we add it to the constructor using `setValidity`. By doing this, the validation function will be called automatically every time an object is created.\n\n## Generics and methods\n\nOur new S4 object is not particularly helpful if we cannot do anything with it. Let’s start by creating a method to display its content. In S4 you normally don’t use print, but rather you use show. If you create a generic for print that will overwrite the base R print , which will then stop working.\n\n`show` is an S4 built-in generic, so we do not need to define one. We only need to define the method for our class.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create an object\nnewAnimal <- new(\"Animals_s4\", species=\"Canis familaris\")\n\n# define the method\nsetMethod(\"show\", signature(\"Animals_s4\"), \n          function(object){\n            cat(paste0(\"Object of class 'Animals_s4'. The species is \",\n                       slot(object, 'species')))\n          })\n          \nshow(newAnimal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class 'Animals_s4'. The species is Canis familaris\n```\n\n\n:::\n:::\n\n\n\nIf you recall our S3 example, this will look familiar. We first define a generic with `setGeneric` and then a method with `setMethod`.\n\nUsing the same syntax, let’s implement the `formatSpecies` method.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# define the generic\nsetGeneric(\"formatSpecies\", function(object) {\n  standardGeneric(\"formatSpecies\")\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"formatSpecies\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# define the method\nsetMethod(\"formatSpecies\", signature(\"Animals_s4\"), \n          function(object){\n            slot(object, 'species') <- stringr::str_to_sentence(\n              slot(object, 'species'))\n            return(object)\n          })\n\n# usage\nnewAnimal <- new(\"Animals_s4\", species=\"canis familaris\")\nshow(newAnimal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class 'Animals_s4'. The species is canis familaris\n```\n\n\n:::\n\n```{.r .cell-code}\nnewAnimal <- formatSpecies(newAnimal)\nshow(newAnimal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class 'Animals_s4'. The species is Canis familaris\n```\n\n\n:::\n:::\n\n\n\nAs for S3, S4 does not have the concept of private methods, so both methods are public.\n\n## Inheritance\n\nLet’s create an S4 class Dog that inherits from `Animals_s4`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetClass('Dog', contains = 'Animals_s4',\n         slots = c(name='character', age = 'numeric'))\n\nnewDog <- new('Dog', species=\"Canis familaris\", name = 'Pluto', age = 4)\n\nshow(newDog)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nObject of class 'Animals_s4'. The species is Canis familaris\n```\n\n\n:::\n:::\n\n\n\nInheritance is made explicit with the use of the argument contains, used in the definition of `Dog`. You will notice that `Dog` inherits the show method from `Animals`. We can create a dedicated `show` method. While we are at it, we can also create the `humanAge` method.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define the methos for print\nsetMethod(\"show\", signature(\"Dog\"), \n          function(object){\n            cat(paste0(\"The dog \", slot(object, 'name'),\n                       \" is \", slot(object, 'age')))\n          })\n\nshow(newDog)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe dog Pluto is 4\n```\n\n\n:::\n\n```{.r .cell-code}\n# define the generic\nsetGeneric(\"humanAge\", function(object) {\n  standardGeneric(\"humanAge\")\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"humanAge\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# define the method\nsetMethod(\"humanAge\", signature(\"Dog\"), \n          function(object){\n            return(slot(object, 'age') * 7)\n          })\n          \nhumanAge(newDog)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 28\n```\n\n\n:::\n:::\n\n\n\n## S4 is not mutable\n\nAs for S3 objects, S4 are not mutable. We cannot modify an object and return a result at the same time. We need to implement the same workaround we saw for S3 objects.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# define the generic\nsetGeneric(\"updateAge\", function(object) {\n  standardGeneric(\"updateAge\")\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"updateAge\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# define the method\nsetMethod(\"updateAge\", signature(\"Dog\"), \n          function(object){\n            oldAge <- slot(object, 'age')\n            slot(object, 'age') <- slot(object, 'age') + 1\n            return(list(object = object, oldAge = oldAge))\n          })\n\n#usage\nshow(newDog)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe dog Pluto is 4\n```\n\n\n:::\n\n```{.r .cell-code}\nres <- updateAge(newDog)\nupdatedDog <- res$object\nshow(updatedDog)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe dog Pluto is 5\n```\n\n\n:::\n\n```{.r .cell-code}\nres$oldAge\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n:::\n\n\n\nIn the code snippet above, we create a method called `updateAge`. In that method we update the slot age , and we also return the old age. To be able to do both operations at once, we must return a list from the method. The list will contain the modified object and the desired return. Finally, in the main environment we need to unpack the list with more assignments.\n\n## S4 wrap up\n\nS4 is based on the same idea as S3. They are both functional OO systems, and they are both non mutable. S4 has a stricter definition. We need to specify exactly what we want in our class, and once created an object’s structure cannot be modified. This can help larger teams as the interfaces are clearer.\n\nS4 added formality might sound great, but you should evaluate carefully if it is worth it. It is often preferable to use the simpler and more R-friendly S3. This is because of better documentation and improved code readability by traditional R developers.\n\nFollow me and subscribe to get notified when part 2 of this series is published, and for other tips on R programming.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}