{
  "hash": "bf94893095303f97b265487fad25d2b9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"How to manage your R configuration like a pro with config\"\ndescription: \"A deep dive into the powerful R package config.\"\ndate: \"2022-08-17\"\ncategories: [r, setup, config]\n---\n\n\n![Photo by Elena Popova on Unsplash](img/cover.jpg)\n\nIf you are a developer you probably have to manage different configurations in different environments like dev, test, or prod. If you are a data analyst you might want to be able to quickly change some parameters or thresholds depending on specific conditions to compare different solutions.\n\nThese scenarios describe the same problem: the configuration problem. Managing configurations is important. The wrong approach will cost you hours trying to make a same simple change to your code.\n\nWhen you deal with a configuration problem, you deal with two issues:\n\n1. How to allow variables to assume different values depending on the runtime environment: dev, test, prod, or whatever you use.\n2. How to allow quick changes to the value of those variables.\n\nThere is another consideration to make to consider if you want to professionally manage your configuration. Your solution should be R-independent. You should be able to import and export configurations between systems.\n\nI have seen several approaches to the configuration problem. Let’s quickly look at them.\n\n# Configuration management options\n\n## Hard coded values\n\nThis is the basic approach. The global variables are not even variables. They are hardcoded wherever they are needed. To change them you have to search the entire code base. This is a nightmare at best. Don’t do this. This approach does not solve any of the configuration issues. If anything, it creates more problems.\n\n## In-code flags\n\nIn-code flags look something like this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#if/else option\nif (runEnv == \"prod\"){\n  varVal <- 1\n} else if(runEnv == \"dev\"){\n  varVal <- 2\n} else {\n  varVal <-3\n}\n\n# switch option\nvarVal <- switch(runEnv,\n                 \"prod\" = 1,\n                 \"dev\" = 2,\n                 3\n)\n```\n:::\n\n\n\nIn-code flags are a great deployment pattern tool, but this is not when they should be used. Using in-code flags to manage the configuration is just marginally better than hardcoding the values. They solve the problem of having different values for different environments, but they do not allow you to quickly change said values. Also, imagine somebody decides to change the name prod to production. Not fun…\n\n## Variables assigned on top of files or functions\n\nThis is a marginal improvement to the hardcoded values. When combined with in-code flags they allow you to have different configurations for different environments. Yet, you still need to know the code base fairly well to find all of them. Still not good enough.\n\n## Variables saved in a config.R file\n\nThis is another small improvement. All the variables are in one place, so they are easy to find. If you combine this with in-code flags, you have different configurations for different environments. The limitation is that this solution is not easily accessible by other systems: you are using an R file that only R can easily read properly. Furthermore, you cannot easily integrate configurations used by other systems.\n\n## Variables saved in a .Renviron file\n\nThis is bad. .Renviron should be reserved for secrets (passwords, tokens, etc), and not committed to the repository. And if you do not commit the file to the repository, how can other developers have access to the global variables?\n\n## Variables saved in a .Rprofile file\n\nThis is better than the .Renviron. Your limitation is the same as the one for the config.R file: this is an R-specific solution therefore it cannot be integrated with other systems.\n\n# The config package\n\nSo, how can you properly manage your configuration in R? The answer is the R package `config`.\n\n`config` allows us to set our variables in a config file, and change them at run time by simply leveraging the global variable `R_CONFIG_ACTIVE`.\n\nLet’s have a look at what this package can do.\n\n## The config ingredients\n\nTo use config we need two ingredients:\n\n1. A global variable called `R_CONFIG_ACTIVE` storing the name of the environment we are using.\n2. A `config.yml` file.\n\nR_CONFIG_ACTIVE is normally set by the system administrator (for example if you use Posit Connect in an enterprise). You can also set it manually, but you need to make sure it is done transparently, so other developers know what they need to do, and if your work targets different environments (test, production) you need to make sure that R_CONFIG_ACTIVE is set up correctly.\n\nNext, you need the config.yml file. This file follows the standard yml syntax. The fact that it is a standard format is the strength of the config package. The package can read yml files created by other systems, and other systems can read R’s yml files.\n\nBelow is an example of a simple config.yml file for a production environment.\n\n```yaml\ndefault:\n  runParallel: FALSE\n  nRuns: 10\nproduction:\n  runParallel: TRUE\n  nRuns: 100\n\n```\n\nIn this particular example, we handle one specific environment: production. For production (`R_CONFIG_ACTIVE == \"production\"`) we use the bottom configuration: `runParallel: TRUE` and `nRuns:100`. In any other environment (`R_CONFIG_ACTIVE != \"production\"`) we use the `defualt` configuration. We will see more examples later.\n\nA few of important things on the yml file:\n\n* You need to have an empty line at the end of the file.\n* You need to have the default configuration. This is the fallback in case the environment is not specified.\n* There must be a space between <key>: and <key value>.\n\nBy default, the config.yml file is named config.yml and it is stored in the project’s root folder. However, we can override these defaults.\n\n## Using the config package\n\n### The get function\n\nThe `get` function is the core of the config package. It is used to retrieve the value of configuration variables.\n\nAssuming you are in production and we are using the `config.yml` above:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# setting the environment for demonstration purpose. In normal use, you will not need to do this\nSys.setenv(R_CONFIG_ACTIVE = 'production')\n# this is another thing I need to do for this demo: I will be handling different config files not stored at root level.\n# In a normal scenario, you will have a single config.yml file stored at project root level, which is where config is\n# by defualt looking for the configuration file. In that case, you do not need to specify the \"file\" argument.\nconfig_path_file <- file.path('posts', '2022-08-17_config_r')\n\n# get all the config variables:\nconfig::get(file=file.path(config_path_file, 'config_1.yml'))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$runParallel\n[1] TRUE\n\n$nRuns\n[1] 100\n```\n\n\n:::\n:::\n\n\n\nMore commonly, you will want to retrieve only a specific key:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get only nRuns:\nconfig::get('nRuns',\n            file=file.path(config_path_file, 'config_1.yml'))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 100\n```\n\n\n:::\n:::\n\n\n\nconfig assumes that you have a file called config.yml in the root folder of your project. If this is not true, you can specify the path to your configuration file using the file argument of the get function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# to get all variables\nconfig::get(file=\"<path_to_file>\")\n# to get a specific variable\nconfig::get(\"<variable_name>\", file=\"<path_to_file>\")\n```\n:::\n\n\n\n### Fallback to default\n\nIn the config file you need to specify a default environment. This will be used if no active configuration is found or recognized. Considering the configuration file above.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set an environment that is not specified in config.yml\nSys.setenv(R_CONFIG_ACTIVE = \"hello\")\n\n# retrieve nRuns\nconfig::get('nRuns',\n            file=file.path(config_path_file, 'config_1.yml'))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n\n\nThe environment `hello` is not recognized. config will use the value set for `default`: 10.\n\n### Inheritance\n\nYou might have some values that are always the same across all environments. You do not need to replicate them in all definitions. You can add them only to default. All other environments will inherit those values from default.\n\nLet’s modify the config file.\n\n```yaml\ndefault:\n  runParallel: FALSE\n  nRuns: 10\n  thisIsACommonVariable: hello\nproduction:\n  runParallel: TRUE\n  nRuns: 100\n  \n```\nNow, let’s try to get `thisIsACommonVariable` for the production environment.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set the environment to \"production\"\nSys.setenv(R_CONFIG_ACTIVE = \"production\")\n\nconfig::get('thisIsACommonVariable',\n            file = file.path(config_path_file, 'config_2.yml'))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hello\"\n```\n\n\n:::\n:::\n\n\n\n`thisIsAcommonVariable` was not defined in `production`: it was inherited from default. What happens is that `config` will first attempt to find the variable you request in the active environment. Failing that, it will look into the definitions for `default`. Unless the `inherit` keyword is used.\n\nYou can have fine control over the inheriting mechanism by using the inherits field in the yml file. Suppose you have three environments: `dev`, `test`, and `production`. Suppose that you want to use the same value for the variable `inheritedKey` in test and in production, and another value in dev and in default. Using inherits you can create the following config.yml:\n\n```yaml\ndefault:\n  key1: 1\n  inheritedKey: hi\n\nproduction:\n  key1: 2\n  inherits: test\n  \ntest:\n  key1: 3\n  inheritedKey: goodbye\n  \ndev:\n  key1: 4\n \n```\n\nLet’s try to get inheritedKey for the different environments.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# fallback to \"default\" environment\nSys.setenv(R_CONFIG_ACTIVE = \"hello\")\n# retrieve inheritedKey\nconfig::get('inheritedKey',\n            file = file.path(config_path_file, 'config_3.yml'))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hi\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# set environment to \"dev\"\nSys.setenv(R_CONFIG_ACTIVE = \"dev\")\n# retrieve inheritedKey\nconfig::get('inheritedKey',\n            file = file.path(config_path_file, 'config_3.yml'))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hi\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# set environment to \"test\"\nSys.setenv(R_CONFIG_ACTIVE = \"test\")\n# retrieve inheritedKey\nconfig::get('inheritedKey',\n            file = file.path(config_path_file, 'config_3.yml'))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"goodbye\"\n```\n\n\n:::\n\n```{.r .cell-code}\n# set environment to \"production\"\nSys.setenv(R_CONFIG_ACTIVE = \"production\")\n# retrieve inheritedKey\nconfig::get('inheritedKey',\n            file = file.path(config_path_file, 'config_3.yml'))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"goodbye\"\n```\n\n\n:::\n:::\n\n\n\nAs expected, default uses the value hi. dev also uses hi, and this is because you did not set any value for inheritKey in dev: dev inherits from default. test uses the value goodbye, as this is what was set for that environment. production also uses goodbye. You did not set the value of inheritedKey in production, but you do not inherit it from default because you specified that you wanted production to inherit from test instead.\n\n## Run R code in config.yml\n\nYou can use R code inside config.yml by adding !expr before in-line R commands. This is particularly useful if you need to set some value based on the hardware where you run the code. For instance, production is likely to have more cores than your local machine, so you can use different settings for parallel computing in the environments. Another use case is if you want to read in another configuration file.\n\n```yaml\ndefault:\n  memSize: !expr sum(seq(1,10))\n  serverConfig: !expr config::get(file=\"serverConfig.yml\")\n  nCores: !expr parallel::detectCores()\n\n```\n\nBe mindful if you do this: your `config.yml` now depends on R. Other systems will not be able to use the file anymore. Depending on your solution architecture this might be okay, but in general avoid tight coupling.\n\nAnother thing to be mindful is that even when you query for a single, specific configuration variable, all the keys are \"executed\". If you use lengthy computations in your config.yml, this will have negative impact on the application performance every time you call `config::get()`. Consider this example:\n\n```yaml\ndefault:\n  var_1: !expr Sys.sleep(3)\n  var_2: \"hi\"\n  \n```\n\nand the result of this benchmark:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.setenv(R_CONFIG_ACTIVE = 'hello')\n\ntictoc::tic()\nconfig::get('var_2',\n            file = file.path(config_path_file, 'config_5.yml'))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hi\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntictoc::toc()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n3.01 sec elapsed\n```\n\n\n:::\n:::\n\n\n\nNote how retrieving the `var_1` took 3 seconds. This is because `config` also run the code for `var_1`.\n\n## Merge\n\nSometimes you might have different configuration files for different components of the system, for instance the database and the server. You can use the `config::merge()` function to combine these two configurations.\n\nSuppose you have two configuration files: `config_server.yml` and `config_database.yml`.\n```yaml\n# config_server.yml\ndefault:\n  runParallel: FALSE\n  serverURL: \"123.456:8080\"\n\n```\n\n```yaml\n# config_database.yml\ndefault:\n  runParallel: TRUE\n  databaseName: fancyDB\ntest:\n  runParallel: FALSE\n  databaseName: fancyDBTest\n  nTests: 3\n\n```\n\nYou can merge the two using `config::merge()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set the environment to \"default\"\nSys.setenv(R_CONFIG_ACTIVE = \"default\")\n# merge database into server\nconfig::merge(\n  base_config = config::get(file='config_server.yml'),\n  merge_config = config::get(file='config_database.yml')\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$serverURL\n[1] \"123.456:8080\"\n\n$runParallel\n[1] TRUE\n\n$databaseName\n[1] \"fancyDB\"\n```\n\n\n:::\n:::\n\n\n\n\n`merge` only merges the configuration for the active environment, in this example `default`.\n\nThe merging order matters. For keys with the same name between the two files, merge keeps values from merge_base. In the example above, after the merge `runParallel` is FALSE, which was the value in the `base_config`: `config_server.yml`. If you reverse the order and make `config_database.yml` the `base_config`, `runParallel` becomes TRUE.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set the environment to \"default\"\nSys.setenv(R_CONFIG_ACTIVE = \"default\")\n# merge server into database\nconfig::merge(\n  base_config = config::get(file='config_database.yml'),\n  merge_config = config::get(file='config_server.yml')\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$databaseName\n[1] \"fancyDB\"\n\n$runParallel\n[1] FALSE\n\n$serverURL\n[1] \"123.456:8080\"\n```\n\n\n:::\n:::\n\n\n\n# Wrap up\n\nThe `config` package is extremely easy to use. All you need is a config.yml file and the global variable `R_CONFIG_ACTIVE`. Once you have those two items all you need to do is to use `config::get()`. It really cannot get any simpler.\n\nBecause the yml format is a standard, you can share configurations with other systems.\n\n`config` official documentation is [here](https://rstudio.github.io/config/articles/introduction.html).\n\nI hope the `config` package will help you manage your configurations in R in an efficient way.\n\nI have more articles coming up on how to unlock the power of R. Follow me if you want to know more.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}