{
  "hash": "3a097d0c8b599c4011047878f2a6c462",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Programmatic plumber - Part 1: error handling and documentation\"\ndescription: \"eturn meaning errors and document your API.\"\ndate: \"2023-12-06\"\ncategories: [ai]\n---\n\n\n![Image generated with Canva AI Magic Media.](img/cover.png)\n\n### Introduction\n\nWelcome to the second part of our series on programmatically developing R `{plumber}` REST APIs. It might be helpful to start with the [first article](../2023-11-22_programmatic_plumber_1/index.qmd) if you haven't already.\n\nIn our previous discussion, we explored how to convert annotated `{plumber}` APIs to programmatic ones. Interestingly, we found that we don't necessarily have to do this, as an annotated plumber file can be passed directly to a `pr()` router. Additionally, we discovered the advantage of mounting multiple plumber APIs to a single router to simplify large APIs.\n\nToday, we're going to delve into two critical aspects of programmatic plumber: error handling and API documentation.\n\n### Handling 404 Errors\n\nLet's begin our exploration of error handling with the 404 error. This error is usually linked with the message “resource not found”. If a user mistakenly enters an incorrect API URL, plumber will respond with a default message, “404 — path not found error”.\n\nUsing programmatic plumber we can intercept the default message and customize it.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We already saw the content of R/myPlot.R and randomLetters.R.  \n# Here I show only R/handler404.R  \n  \n############# R/handler404.R  \n# This is the error handler function  \nhandler404 <- function(req, res){  \n  # do not do this in real API: not found should always be 404.  \n  # We do 403 here just to demonstrate that this apprach works  \n  res$status <- 403  \n # return a custom response  \n res$body <- sprintf('Ops, resource not found: %s', req$PATH_INFO)  \n}  \n\n\n############ plumber.R  \n# set up  \nlibrary(plumber)  \nlapply(list.files(here::here('R'),   \n         full.names = TRUE) ,   \n    function(d){source(d)})  \n\n# define empty router  \nroot <- pr()  \n# define plot endpoint  \nplots <- pr() %>%  \n   pr_get(path = '/myPlot',  \n          handler = myPlot,  \n          serializer = serializer_png())  \n\n# define random letters endpoint  \nrandLetters <- pr() %>%  \n   pr_get(path = '/randLetters',  \n          handler = randomLetters,  \n          serializer = serializer_json())  \n\n# mount everthing  \nroot %>%  \n   pr_mount('/mountPath_1', plots) %>%  \n   pr_mount(\"/mountPath_2\", randLetters) %>%  \n  # here we add the 404 error handler.  \n   pr_set_404(handler404) %>%  \n   pr_run()\n```\n:::\n\n\n\nPlease be aware that the result status code was switched from 404 to 403. This was merely to show it's possible, but it's not something you should typically do without a good reason. 403 errors differ significantly from 404 errors.\n\nIt's worth mentioning that if we opt for mounting, we must define `pr_set_404` at the root route level. Any 404 handlers set within the “child” APIs won't be taken into consideration.\n\n### Handling Server Errors\n\nThe 404 error mentioned above typically results from a user mistake: an incorrect URL leading to a non-existent resource.\n\nHowever, there's a different type of error: the server error, often a 500 error. If you've worked with plumber, you might be familiar with this. The response is usually a vague _“An error has occurred”_, which doesn't provide much insight for developers or users.\n\nWe can improve on this. By utilizing the method `pr_set_error`, we can dictate how errors are reported.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We already saw the content of R/myPlot.R and randomLetters.R.  \n# Here I show only R/errorHandler.R and R/giveError.R\n\n# define empty router  \nroot <- pr()  \n  \n################# R/errorHandler.R  \n# err is the error message captured by the code  \nerrorHandler <- function(req, res, err = 'default'){  \n  # here we can fine tune our error message to give different info depending  \n  # on the endpoint that was hit, for example, or give different status codes  \n  # depending on the type of error we detect  \n  # Note. Here we set the error code to 505. Normally you should never do this,  \n  # as 500 and 505 are two very different types of errors.  \n  res$status <- 505    \n    \n # return a custom message  \n  list(error_source = sprintf(\"Error from endpoint: %s\", req$PATH_INFO),  \n       error_message = as.character(err))  \n}  \n\n\n############## R/giveError.R  \n# in this function we try to get the log of a string.   \n# This will always cause an error  \ngiveError <- function(){    \n log('a')  \n}\n\n\n########### plumber.R  \n# set up  \nlibrary(plumber)  \nlapply(list.files(here::here('R'),   \n         full.names = TRUE) ,   \n    function(d){source(d)})  \n# define empty router  \nroot <- pr()  \n# define plot endpoint  \nplots <- pr() %>%  \n   pr_get(path = '/myPlot',  \n          handler = myPlot,  \n          serializer  = serializer_png())  \n# define random letters endpoint  \nrandLetters <- pr() %>%  \n   pr_get(path = '/randLetters',  \n          handler = randomLetters,  \n          serializer  = serializer_json())  \n# this is an entrypoint that will always return an error  \nerrGenerator <- pr() %>%  \n  pr_get(path = '/giveError',  \n         handler = giveError,  \n         serializer  = serializer_json()) %>%  \n # add the error handler function  \n  pr_set_error(errorHandler)  \n# mount to root  \nroot %>%  \n  pr_mount('/mountPath_1', plots) %>%  \n  pr_mount(\"/mountPath_2\", randLetters) %>%   \n  pr_mount('/mountPath_3', errGenerator) %>%  \n  pr_run()\n```\n:::\n\n\n\nIt's important to note that unlike `pr_set_404`, `pr_set_error` must be defined within the \"child\" API. This is beneficial as it provides granular control over error handling. We can establish different error handling procedures and distinct error messages based on the router. In the example above we simply provided a generic hanlder at the root level to handle any server error.\n\nKeep in mind, for easier file management, consider defining the `plots` and `randomLetters` routers in separate files. This keeps `plumber.R` manageable, as we discussed in the first article of this series.\n\n### Documentation\n\nR plumber APIs are documented using the openapi standard. Essentially, it's a comprehensive JSON file filled with metadata about the API. There are several renderer that interpret the JSON into a user-friendly format. The default one with plumber is `swagger`, but `redoc` and `rapidoc` are also viable options. In this section, we'll explore how to switch the interpreter, the reasons for doing so, and lastly, how to add documentation to the API.\n\n### Switching openaAPI interpreter\n\nSwitching the `openAPI` interpreter is quite straightforward. Simply load the necessary libraries and add a `pr_set_docs` call to your API's main router.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n############ plumber.R  \n# set up  \nlibrary(plumber)  \nlibrary(redoc) # if you want to use redoc  \nlibrary(rapidoc) # if you want to use rapidoc  \n  \nlapply(list.files(here::here('R'),   \n         full.names \\= TRUE) ,   \n    function(d){source(d)})  \n\n# define empty router  \nroot <- pr()  \n\n# define plot endpoint  \nplots <- pr() %>%  \n   pr_get(path \\= '/myPlot',  \n          handler \\= myPlot,  \n          serializer  \\= serializer_png())  \n\n# define random letters endpoint  \nrandLetters <- pr() %>%  \n   pr_get(path \\= '/randLetters',  \n          handler \\= randomLetters,  \n          serializer  \\= serializer_json())  \n\n# mount to root  \nroot %>%  \n # comment out the two pr_set_docs you do not want  \n  pr_set_docs('swagger') %>% # default, no need to explicitly define it  \n  pr_set_docs('redoc') %>% # to use redoc  \n  pr_set_docs('rapidoc') %>% # to use rapidoc  \n  pr_mount('/mountPath_1', plots) %>%  \n  pr_mount(\"/mountPath_2\", randLetters) %>%   \n  pr_run()\n```\n:::\n\n\n\nWhile there are some aesthetic variations, the three interpreters also come with distinct features. For example, the `redoc`interpreter includes a quick download button for the OpenAPI JSON specification file, which we'll explore in more detail shortly. The `rapidoc` interpreter, on the other hand, provides an option to upload a JSON file. This is particularly useful for testing POST endpoints if you'd rather not employ an external tool such as Postman.\n\nBeyond these disparities, the choice between the three interpreters primarily hinges on personal preference.\n\nDuring our use of the `redoc` interpreter, we discovered how it can facilitate the download of the `OpenAPI` JSON specification. This is a considerably large file, and here's a sneak peek at the beginning:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{  \n    \"openapi\": [  \n        \"3.0.3\"  \n    ],  \n    \"info\": {  \n        \"description\": [  \n            \"API Description\"          \n\t\t\t  ],  \n        \"title\": [  \n            \"API Title\"  \n        ],  \n        \"version\": [  \n            \"1.0.0\"  \n        ]  \n},  \n    \"paths\": {  \n        \"/mountPath_1/myPlot\": {  \n            \"get\": {  \n                \"summary\": [  \n                    null  \n                ],  \n                \"description\": [  \n                    null  \n                ],  \n...\n```\n:::\n\n\n\nWe can now use this file to add documentation to our API. For example, we could change it this:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{  \n    \"openapi\": [  \n        \"3.0.3\"  \n    ],  \n    \"info\": {  \n        \"description\": [  \n            \"Dummy API to demonstrate how to use programmatic plumber\"          \n\t\t\t  ],  \n        \"title\": [  \n            \"Programmatic plumber API\"  \n        ],  \n        \"version\": [  \n            \"0.0.1\"  \n        ]  \n},  \n    \"paths\": {  \n        \"/mountPath_1/myPlot\": {  \n            \"get\": {  \n                \"summary\": [  \n                    \"Summary for myPlot endpoint\"  \n                ],  \n                \"description\": [  \n                    \"Description for myPlot endpoint\"  \n                ],  \n...\n```\n:::\n\n\n\n\nIn order to use the JSON file, we add the method `pr_set_api_spec` to the root router:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nroot %>%  \n  pr_set_api_spec(jsonlite::fromJSON(here::here(\"specs\", \"openapi.JSON\"))) %>%  \n  pr_mount('/mountPath_1', plots) %>%  \n  pr_mount(\"/mountPath_2\", randLetters)  \n %>%  pr_run()\n```\n:::\n\n\n\n### Conclusion\n\nAnd that's a wrap on the second installment of our series on the programmatic `{plumber}`.\n\nWe've delved into the usage of `pr_set_404` and `pr_set_error` for error handling, as well as `pr_set_docs` and `pr_set_api_sepc` for tailoring the appearance of the API.\n\nIn our next piece, we're going to unlock the true potential of programmatic plumber by examining filters and hooks.\n\n### Resources\n\n* [Programmatic plumber documentation](https://www.rplumber.io/articles/programmatic-usage.html)",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}