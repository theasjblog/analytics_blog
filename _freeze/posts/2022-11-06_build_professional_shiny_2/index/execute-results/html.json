{
  "hash": "a71ddc63c27d21bb77222db17d362b76",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"How to build a professional R Shiny app - part 2\"\ndescription: \"In part 1 we look at what to do before we get coding. In this part 2 we will look at setting up the Shiny app and using modules.\"\ndate: \"2022-11-06\"\ncategories: [r, rshiny]\n---\n\n\n![Photo by Agence Olloweb on Unsplash](img/cover.jpg)\n\nIn the [first part](/posts/2022-10-16_build_professional_shiny_1/index.html) we saw how we can hit the ground running when developing a Shiny app. In this part we will have a look at how we can structure our code base. Note that for this simple app we will not use modules. I will introduce modules in another article. The main topics we will introduce in this article are golem and modules. This article is not meant to be a guide on either of those two techniques. However, I will explain the most important concepts.\n\n## The set up\n\nNow we have enough information to start coding your app. You want to start with solid foundations, so make sure you have read my article about setting up R projects. In particular you should:\n\n* Create a repository. In fact, more than one. You will want one repository for the front-end, and one for the backend. This allows you to test things independently, re-use the logic, and have smoother deployments. Since the app in our example is very small, we will use only one repository.\n* Use [renv](/posts/2022-07-22_renv_r_env_reproducible/index.html).\n\nI would suggest you start with the business logic. Abstract the logic from the app, and create a package for it. In this example we are not using a separate package for the business logic because the app is extremely simple.\n\n## golem\n\nOnce you have the business code ready, you can get started with the front-end. But how can you organize your R Shiny code base?\n\nYou have two options:\n\n1. Use golem. golem is an excellent framework that can give you the skeleton of a well structured Shiny app with just one line of code: golem::create_golem().\n2. Create an equivalent structure manually. golem uses the standard structure of an R package. You can follow [this article](/posts/2022-07-13_setup_r_for_success/index.html) to get started. However, I do recommend you spend some time familiarizing yourself with golem, as it will make your life a lot easier.\n\nIn this example I will use golem, but the final result should be the same regardless of the approach you use.\n\nTo get started, all you need to do is call golem::create_golem('my_path_for_the_golem_app'). This will start the golem framework in the path you specify. I strongly suggest you also activate renv right now. You can start the golem app template with golem::run_dev().\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# start the framework\ngolem::create_golem('path_to_golem_app')\n# activate renv\nrenv::activate()\n# install dependencies\ninstall.packages(c('golem', 'shiny')\n# start template app\ngolem::run_dev()\n```\n:::\n\n\n\ngolem will create a structure like this one.\n\n```bash\n.\n├── .Rprofile\n├── .gitignore\n├── R\n│   └── [...]\n├── inst\n│   └── [...]\n├── dev\n│   └── [...]\n├── man\n│   └── [...]\n├── README.md\n├── renv\n│   └── [...]\n├── renv.lock\n└── thisArticleProject.Rproj\n```\n\nThe main folders we need to worry about are R, inst, and dev.\n\n### R\n\nIn this folder you find the main app code. Specifically you will find 4 files:\n\n* app_server.R. This is the server logic of the app: what the UI elements do and how they interact with each other.\n* app_ui.R. This is the UI logic of the app: which UI elements are used, and where they are.\n* app_config.R. Configuration parameters used by the app and golem. For basic usage, you don’t need to worry about this.\n* run_app.R. This can be used to initialize the app.\n\nFor this app, we only need to worry about app_server.R and app_ui.R.\n\n### inst\n\nIn agreement with R standards, init contains “extra” files. In the default golem app, these include the YAML configuration file and the favicon. We do not use this folder for this app.\n\n### dev\n\nThis is essentially a practical guide to the different steps of developing a golem app, from start to deployment. We do not use this folder for this app.\n\n## Customizing our app\n\nNow we can start to modify the existing ui and server functions. We are going to use this [R Shiny demo app](https://shiny.rstudio.com/gallery/kmeans-example.html) as our starting point.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#####\n## Server logic.\n#####\n\n#' The application server-side\n#'\n#' @param input,output,session Internal parameters for {shiny}.\n#'     DO NOT REMOVE.\n#' @import shiny\n#' @noRd\napp_server <- function(input, output, session) {\n  # Define the required reactive values\n  rV <- reactiveValues(selectorsPanelResults = NULL)\n  # call the selectors module\n  rV$selectorsPanelResults <- mod_selectorsPanel_server('selectorsPanel_mod')\n\n  # the plot logic\n  output$plot1 <- renderPlot({\n    # create colours for the 9 possible clusters\n    palette(c(\"#E41A1C\", \"#377EB8\", \"#4DAF4A\", \"#984EA3\",\n              \"#FF7F00\", \"#FFFF33\", \"#A65628\", \"#F781BF\", \"#999999\"))\n\n    # plot\n    par(mar = c(5.1, 4.1, 0, 1))\n    plot(rV$selectorsPanelResults()$selectedData,\n         col = rV$selectorsPanelResults()$clusters$cluster,\n         pch = 20, cex = 3)\n    points(rV$selectorsPanelResults()$clusters$centers, pch = 4, cex = 4, lwd = 4)\n  })\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n######\n## UI logic.\n#####\n#' The application User-Interface\n#'\n#' @param request Internal parameter for `{shiny}`.\n#'     DO NOT REMOVE.\n#' @import shiny\n#' @noRd\napp_ui <- function(request) {\n\n  tagList(\n    # Leave this function for adding external resources\n    golem_add_external_resources(),\n    # Your application UI logic\n\n    pageWithSidebar(\n      headerPanel('Iris k-means clustering'),\n      sidebarPanel(\n        mod_selectorsPanel_ui('selectorsPanel_mod')\n      ),\n      mainPanel(\n        plotOutput('plot1')\n      )\n    )\n  )\n}\n\n#' Add external Resources to the Application\n#'\n#' This function is internally used to add external\n#' resources inside the Shiny application.\n#'\n#' @import shiny\n#' @importFrom golem add_resource_path activate_js favicon bundle_resources\n#' @noRd\ngolem_add_external_resources <- function() {\n  add_resource_path(\n    \"www\",\n    app_sys(\"app/www\")\n  )\n\n  tags$head(\n    favicon(),\n    bundle_resources(\n      path = app_sys(\"app/www\"),\n      app_title = \"mediumApp\"\n    )\n    # Add here other external resources\n    # for example, you can add shinyalert::useShinyalert()\n  )\n}\n```\n:::\n\n\n\n\n## Modules\n\nNote that we have made one major change from the original: we have added a module to enclose the left panel. We did so that in part 3 of this series we can show how to test Shiny server functions.\n\nShiny models are special functions encapsulating functionalities. In our app, we encapsulated in a module the left hand-side selectors.\n\nThe easiest way to create the backbone of a module is to call the function golem::add_module(<\"my_module_name\">).\n\nThe module is contained in a file called mod_selectorsPanel.R. The prefix mod_ tells us that the file contains a module. Inside the file we find both the UI and the server function. Those functions have the same name as the file, with the added suffix _ui or _server. What happens inside those functions is simple. We monitor the inputs and update the data.frames selectedData and clusters at every change. The two data.frames are returned to the main app_server.R. Note how the module is called as any other normal function: mod_selectorsPanel_server(). The argument passed to the function is the name of the session id where the namespace is created.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' selectorsPanel UI Function\n#'\n#' @description A shiny Module.\n#'\n#' @param id,input,output,session Internal parameters for {shiny}.\n#'\n#' @noRd\n#'\n#' @importFrom shiny NS tagList\nmod_selectorsPanel_ui <- function(id){\n  ns <- NS(id)\n  vars <- setdiff(names(iris), \"Species\")\n  tagList(\n    selectInput(ns('xcol'), 'X Variable', vars),\n    selectInput(ns('ycol'), 'Y Variable', vars, selected = vars[[2]]),\n    numericInput(ns('clusters'), 'Cluster count', 3, min = 1, max = 9)\n  )\n}\n\n#' selectorsPanel Server Functions\n#'\n#' @noRd\nmod_selectorsPanel_server <- function(id){\n  moduleServer( id, function(input, output, session){\n    rV <- reactiveValues(selectedData = NULL,\n                         clusters = NULL)\n    ns <- session$ns\n    # update the required datasets whenever one of inputs changes.\n    observeEvent(list(input$xcol, input$ycol, input$clusters),{\n      # make sure that the selectors have been intialized and\n      # are not NULL\n      req(input$clusters)\n      req(input$ycol)\n      req(input$xcol)\n\n      rV$selectedData <- iris[, c(input$xcol, input$ycol)]\n      rV$clusters <- kmeans(rV$selectedData, input$clusters)\n    })\n\n    return(reactive(list(selectedData = rV$selectedData,\n                         clusters = rV$clusters)))\n  })\n}\n```\n:::\n\n\nThe UI and server functions of our module.\n\n## Run the app\n\nOur app is now ready, and we can run calling golem::run_dev().\n\n![Our app is now running. Image by the author.](img/appRun.png)\n\n## Conclusion\n\nIn this second part of the series we looked at how we can use golem to set up an app. golem adapts the structure of a standard R package to a Shiny app. golem also provides several utility functions to work with your app, including to initialize the app and to create modules.\n\nModules are special functions used to encapsulate related UI and server functionalities. Modules enable reusability and are testable.\n\nIn the next article we will look at how we can test the app.\n\n## Links\n\n* The best guide on building Shiny apps: [Enginnering Shiny](https://engineering-shiny.org/).\n* The [first article](/posts/2022-10-16_build_professional_shiny_1/index.html) of the series.\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}